---
title: Testing Guide
description: How to test code that uses cldpd
author: zoobzio
published: 2026-02-21
updated: 2026-02-22
tags:
  - Testing
  - Guides
---

# Testing Guide

How to test code that depends on cldpd without requiring Docker.

## The Runner Interface

The `Runner` interface is the testing boundary. Every Docker operation flows through it. Replace it with a test double and the Dispatcher works identically -- it cannot tell the difference.

```go
type Runner interface {
    Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
    Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
    Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
    Stop(ctx context.Context, container string, timeout time.Duration) error
}
```

## Writing a Mock Runner

A mock Runner gives you full control over what the Dispatcher sees:

```go
type mockRunner struct {
    buildFn func(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
    runFn   func(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
    execFn  func(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
    stopFn  func(ctx context.Context, container string, timeout time.Duration) error
}

func (m *mockRunner) Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error {
    if m.buildFn != nil {
        return m.buildFn(ctx, tag, dir, buildArgs)
    }
    return nil
}

func (m *mockRunner) Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error) {
    if m.runFn != nil {
        return m.runFn(ctx, opts, stdout)
    }
    return 0, nil
}

func (m *mockRunner) Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error) {
    if m.execFn != nil {
        return m.execFn(ctx, container, cmd, stdout)
    }
    return 0, nil
}

func (m *mockRunner) Stop(ctx context.Context, container string, timeout time.Duration) error {
    if m.stopFn != nil {
        return m.stopFn(ctx, container, timeout)
    }
    return nil
}
```

Nil function fields default to success. Set only the fields relevant to your test.

## Testing the Start Flow

Verify that the Dispatcher builds the correct image and returns a functioning Session:

```go
func TestMyApp_DispatchesCorrectly(t *testing.T) {
    var capturedTag string
    var capturedOpts cldpd.RunOptions

    r := &mockRunner{
        buildFn: func(_ context.Context, tag string, _ string, _ map[string]string) error {
            capturedTag = tag
            return nil
        },
        runFn: func(_ context.Context, opts cldpd.RunOptions, stdout io.Writer) (int, error) {
            capturedOpts = opts
            stdout.Write([]byte("team leader output\n"))
            return 0, nil
        },
    }

    d := cldpd.NewDispatcher(podsDir, r)
    session, err := d.Start(ctx, "myrepo", "https://github.com/org/repo/issues/1")
    // Assert err is nil

    // Drain events
    var output []string
    for event := range session.Events() {
        if event.Type == cldpd.EventOutput {
            output = append(output, event.Data)
        }
    }

    code, err := session.Wait()
    // Assert on capturedTag, capturedOpts, output, code, err
}
```

## Testing the Event Stream

Verify that events arrive in the expected order:

```go
func TestMyApp_EventSequence(t *testing.T) {
    r := &mockRunner{
        runFn: func(_ context.Context, _ cldpd.RunOptions, stdout io.Writer) (int, error) {
            stdout.Write([]byte("line 1\nline 2\n"))
            return 0, nil
        },
    }

    d := cldpd.NewDispatcher(podsDir, r)
    session, _ := d.Start(ctx, "myrepo", issueURL)

    var types []cldpd.EventType
    for event := range session.Events() {
        types = append(types, event.Type)
    }

    // Expected: BuildStarted, BuildComplete, ContainerStarted, Output, Output, ContainerExited
}
```

## Testing Error Paths

Simulate failures by returning errors from the mock:

```go
// Build failure -- Start returns error, no Session
r := &mockRunner{
    buildFn: func(_ context.Context, _ string, _ string, _ map[string]string) error {
        return cldpd.ErrBuildFailed
    },
}

// Container exits non-zero -- Session emits ContainerExited with code
r := &mockRunner{
    runFn: func(_ context.Context, _ cldpd.RunOptions, _ io.Writer) (int, error) {
        return 1, nil
    },
}

// Runtime error -- Session emits EventError
r := &mockRunner{
    runFn: func(_ context.Context, _ cldpd.RunOptions, _ io.Writer) (int, error) {
        return -1, fmt.Errorf("process killed")
    },
}

// Session not found on resume -- Exec returns error
r := &mockRunner{
    execFn: func(_ context.Context, _ string, _ []string, _ io.Writer) (int, error) {
        return -1, cldpd.ErrSessionNotFound
    },
}
```

Use `errors.Is` to check for specific sentinel errors:

```go
if !errors.Is(err, cldpd.ErrBuildFailed) {
    t.Errorf("expected ErrBuildFailed, got %v", err)
}
```

## Testing Graceful Shutdown

Verify that Stop terminates the session:

```go
func TestMyApp_GracefulStop(t *testing.T) {
    r := &mockRunner{
        runFn: func(ctx context.Context, _ cldpd.RunOptions, _ io.Writer) (int, error) {
            <-ctx.Done() // Block until cancelled
            return 137, nil
        },
        stopFn: func(_ context.Context, _ string, _ time.Duration) error {
            return nil
        },
    }

    d := cldpd.NewDispatcher(podsDir, r)
    session, _ := d.Start(ctx, "myrepo", issueURL)

    err := session.Stop(context.Background())
    // Assert err is nil

    code, _ := session.Wait()
    // Assert code == 137
}
```

## Testing Pod Discovery

Pod discovery operates on the filesystem. Create temporary directories with `t.TempDir()`:

```go
func TestDiscovery(t *testing.T) {
    podsDir := t.TempDir()

    // Create a valid pod
    podDir := filepath.Join(podsDir, "myrepo")
    os.MkdirAll(podDir, 0755)
    os.WriteFile(filepath.Join(podDir, "Dockerfile"), []byte("FROM scratch\n"), 0644)

    pod, err := cldpd.DiscoverPod(podsDir, "myrepo")
    // Assert on pod.Name, pod.Dir, pod.Dockerfile
}
```

To test with configuration, write a `pod.json` into the pod directory:

```go
os.WriteFile(filepath.Join(podDir, "pod.json"), []byte(`{
    "image": "custom:v1",
    "env": {"KEY": "value"},
    "inheritEnv": ["ANTHROPIC_API_KEY"],
    "mounts": [{"source": "/tmp/data", "target": "/data", "readOnly": true}]
}`), 0644)
```

## Integration Tests

Integration tests that require Docker live in `testing/integration/`. They are guarded by a Docker availability check:

```go
func dockerAvailable() bool {
    cmd := exec.Command("docker", "info")
    cmd.Stdout = io.Discard
    cmd.Stderr = io.Discard
    return cmd.Run() == nil
}

func TestDockerRunner_Build(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }
    if !dockerAvailable() {
        t.Skip("Docker not available")
    }
    // Test against real Docker
}
```

Run integration tests explicitly:

```bash
make test-integration
```

Unit tests skip integration tests automatically in short mode:

```bash
make test-unit
```

## Test Helpers

The `testing/` package provides assertion helpers:

```go
import cldpdtest "github.com/zoobzio/cldpd/testing"

cldpdtest.AssertNoError(t, err)
cldpdtest.AssertError(t, err)
cldpdtest.AssertEqual(t, got, want)
```

All helpers call `t.Helper()` for accurate line reporting.

## Next Steps

- [Troubleshooting](2.troubleshooting.md) -- Common errors and debugging
- [API Reference](../3.reference/1.api.md) -- Function signatures and behaviour
- [Types Reference](../3.reference/2.types.md) -- Type definitions and error types
