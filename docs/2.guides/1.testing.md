---
title: Testing Guide
description: How to test code that uses cldpd
author: zoobzio
published: 2026-02-21
updated: 2026-02-21
tags:
  - Testing
  - Guides
---

# Testing Guide

How to test code that depends on cldpd without requiring Docker.

## The Runner Interface

The `Runner` interface is the testing boundary. Every Docker operation flows through it. Replace it with a test double and the Dispatcher works identically -- it cannot tell the difference.

```go
type Runner interface {
    Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
    Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
    Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
}
```

## Writing a Mock Runner

A mock Runner gives you full control over what the Dispatcher sees:

```go
type mockRunner struct {
    buildFn func(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
    runFn   func(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
    execFn  func(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
}

func (m *mockRunner) Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error {
    if m.buildFn != nil {
        return m.buildFn(ctx, tag, dir, buildArgs)
    }
    return nil
}

func (m *mockRunner) Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error) {
    if m.runFn != nil {
        return m.runFn(ctx, opts, stdout)
    }
    return 0, nil
}

func (m *mockRunner) Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error) {
    if m.execFn != nil {
        return m.execFn(ctx, container, cmd, stdout)
    }
    return 0, nil
}
```

Nil function fields default to success. Set only the fields relevant to your test.

## Testing the Start Flow

Verify that the Dispatcher builds the correct image and passes the right options:

```go
func TestMyApp_DispatchesCorrectly(t *testing.T) {
    var capturedTag string
    var capturedOpts cldpd.RunOptions

    r := &mockRunner{
        buildFn: func(_ context.Context, tag string, _ string, _ map[string]string) error {
            capturedTag = tag
            return nil
        },
        runFn: func(_ context.Context, opts cldpd.RunOptions, stdout io.Writer) (int, error) {
            capturedOpts = opts
            stdout.Write([]byte("team leader output"))
            return 0, nil
        },
    }

    d := cldpd.NewDispatcher(podsDir, r)
    code, err := d.Start(ctx, "myrepo", "https://github.com/org/repo/issues/1", &buf)

    // Assert on capturedTag, capturedOpts, buf contents, code, err
}
```

## Testing Error Paths

Simulate failures by returning errors from the mock:

```go
// Build failure
r := &mockRunner{
    buildFn: func(_ context.Context, _ string, _ string, _ map[string]string) error {
        return cldpd.ErrBuildFailed
    },
}

// Container exits non-zero
r := &mockRunner{
    runFn: func(_ context.Context, _ cldpd.RunOptions, _ io.Writer) (int, error) {
        return 1, nil
    },
}

// Session not found on resume
r := &mockRunner{
    execFn: func(_ context.Context, _ string, _ []string, _ io.Writer) (int, error) {
        return -1, cldpd.ErrSessionNotFound
    },
}
```

Use `errors.Is` to check for specific sentinel errors:

```go
if !errors.Is(err, cldpd.ErrBuildFailed) {
    t.Errorf("expected ErrBuildFailed, got %v", err)
}
```

## Testing Pod Discovery

Pod discovery operates on the filesystem. Create temporary directories with `t.TempDir()`:

```go
func TestDiscovery(t *testing.T) {
    podsDir := t.TempDir()

    // Create a valid pod
    podDir := filepath.Join(podsDir, "myrepo")
    os.MkdirAll(podDir, 0755)
    os.WriteFile(filepath.Join(podDir, "Dockerfile"), []byte("FROM scratch\n"), 0644)

    pod, err := cldpd.DiscoverPod(podsDir, "myrepo")
    // Assert on pod.Name, pod.Dir, pod.Dockerfile
}
```

To test with configuration, write a `pod.json` into the pod directory:

```go
os.WriteFile(filepath.Join(podDir, "pod.json"), []byte(`{
    "image": "custom:v1",
    "env": {"KEY": "value"}
}`), 0644)
```

## Integration Tests

Integration tests that require Docker live in `testing/integration/`. They are guarded by a Docker availability check:

```go
func dockerAvailable() bool {
    cmd := exec.Command("docker", "info")
    cmd.Stdout = io.Discard
    cmd.Stderr = io.Discard
    return cmd.Run() == nil
}

func TestDockerRunner_Build(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }
    if !dockerAvailable() {
        t.Skip("Docker not available")
    }
    // Test against real Docker
}
```

Run integration tests explicitly:

```bash
make test-integration
```

Unit tests skip integration tests automatically in short mode:

```bash
make test-unit
```

## Test Helpers

The `testing/` package provides assertion helpers:

```go
import cldpdtest "github.com/zoobzio/cldpd/testing"

cldpdtest.AssertNoError(t, err)
cldpdtest.AssertError(t, err)
cldpdtest.AssertEqual(t, got, want)
```

All helpers call `t.Helper()` for accurate line reporting.

## Next Steps

- [Troubleshooting](2.troubleshooting.md) -- Common errors and debugging
- [API Reference](../3.reference/1.api.md) -- Function signatures and behaviour
- [Types Reference](../3.reference/2.types.md) -- Type definitions and error types
