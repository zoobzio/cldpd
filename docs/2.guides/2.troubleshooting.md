---
title: Troubleshooting
description: Common errors, debugging steps, and edge cases
author: zoobzio
published: 2026-02-21
updated: 2026-02-22
tags:
  - Troubleshooting
  - Guides
---

# Troubleshooting

Common errors and how to resolve them.

## Docker Is Not Available

**Error:** `docker is not available`

**Cause:** The Docker daemon is not running or the current user does not have permission to access it.

**Steps:**

1. Verify Docker is installed: `docker --version`
2. Start the Docker daemon: `sudo systemctl start docker` (Linux) or open Docker Desktop (macOS)
3. Verify access: `docker info`
4. If permission denied, add your user to the docker group: `sudo usermod -aG docker $USER` (requires re-login)

cldpd runs `docker info` as a preflight check before any operation. If this fails, no further work is attempted.

## Pod Not Found

**Error:** `pod not found: <name>`

**Cause:** No directory exists at `~/.cldpd/pods/<name>/`.

**Steps:**

1. Check the pod directory exists: `ls ~/.cldpd/pods/`
2. Verify spelling -- the pod name is the directory name, case-sensitive
3. Create the pod directory if missing: `mkdir -p ~/.cldpd/pods/<name>`

## Invalid Pod: Dockerfile Not Found

**Error:** `invalid pod: Dockerfile not found: <name>`

**Cause:** The pod directory exists but does not contain a file named `Dockerfile`.

**Steps:**

1. Check the pod directory contents: `ls ~/.cldpd/pods/<name>/`
2. Verify the filename is exactly `Dockerfile` (capital D, no extension)
3. Create the Dockerfile if missing

## Image Build Failed

**Error:** `image build failed: exit code <N>`

**Cause:** The Docker image build failed. This is a problem in the Dockerfile, not in cldpd.

**Steps:**

1. Build the image manually to see full output: `docker build ~/.cldpd/pods/<name>/`
2. Common causes:
   - Invalid Dockerfile syntax
   - Failed `RUN` command (package install failure, network error)
   - Missing build context files
   - Invalid base image
3. Fix the Dockerfile and retry

## Container Exited With Error

**Observed via:** `EventContainerExited` with a non-zero `Code`, or `EventError` in the event stream.

**Cause:** The container ran but exited with a non-zero status. This means Claude Code or the command inside the container failed.

**Steps:**

1. Check the output events -- the team leader's narration may indicate what went wrong
2. Common exit codes:
   - `1` -- General error (Claude Code encountered a problem)
   - `2` -- Misuse of shell command (bad arguments to claude)
   - `137` -- Container was killed (OOM or manual `docker kill`)
   - `139` -- Segmentation fault
3. Verify environment variables are set correctly in `pod.json` (especially `ANTHROPIC_API_KEY` via `inheritEnv` or `env`)
4. Try running the container manually: `docker run -it <image> /bin/sh`

## No Running Session for Pod

**Error:** `no running session for pod: cldpd-<name>`

**Cause:** `cldpd resume` was called but no container named `cldpd-<name>` is currently running.

**Steps:**

1. Check if the container is running: `docker ps --filter name=cldpd-<name>`
2. If the container has already exited, resume is not possible -- containers use `--rm` and are cleaned up on exit
3. Start a new session with `cldpd start`

Note: Start creates containers with unique session IDs (`<name>-<hex8>`), but Resume looks for containers named `cldpd-<name>`. This means Resume targets the deterministic name, not the session ID.

## Container Name Conflict

**Error:** Docker reports a name conflict when starting a pod.

**Cause:** A container with the same session ID already exists. This is extremely unlikely with random session IDs but can happen if a previous run did not clean up (e.g., the process was killed before `--rm` could take effect).

**Steps:**

1. List matching containers: `docker ps -a --filter name=<podname>`
2. Remove stale containers: `docker rm -f <container-name>`
3. Retry `cldpd start`

## Container Stop Failed

**Error:** `container stop failed: exit code <N>`

**Cause:** `Session.Stop` called `docker stop` and it failed for a reason other than "container not found."

**Steps:**

1. Check if the container still exists: `docker ps -a --filter name=<container>`
2. Force-kill the container manually: `docker kill <container>`
3. Remove it: `docker rm -f <container>`

If the container was already removed before Stop was called, Stop returns nil -- this is not an error.

## Mount Source Path Not Found

**Error:** Docker reports the mount source path does not exist, or the mount silently produces an empty directory in the container.

**Cause:** The `source` path in a mount entry does not point to an existing file or directory on the host.

**Steps:**

1. Verify the source path exists on the host: `ls -la <source path>`
2. Mount source paths support `~` expansion -- `~/keys` is expanded to `/home/user/keys` (or equivalent) during pod discovery. However, `~user` syntax is not supported.
3. If using `~`, ensure the resolved path exists
4. Relative paths are passed to Docker as-is and may not resolve as expected -- use absolute paths or `~` for reliability

## Template Read Error

**Error:** `read template.md: <io error>`

**Cause:** The `template.md` file exists in the pod directory but cannot be read (typically a permissions problem).

**Steps:**

1. Check file permissions: `ls -la ~/.cldpd/pods/<name>/template.md`
2. Fix permissions: `chmod 644 ~/.cldpd/pods/<name>/template.md`
3. If the file is not needed, remove it -- `template.md` is optional

Note: An absent `template.md` is fine -- the prompt is used without a template. Only a present-but-unreadable file causes an error.

## pod.json Parse Error

**Error:** `parse pod.json: <json error>`

**Cause:** The `pod.json` file exists but contains invalid JSON.

**Steps:**

1. Validate the JSON: `python3 -m json.tool ~/.cldpd/pods/<name>/pod.json`
2. Common issues:
   - Trailing commas (not valid in JSON)
   - Comments (JSON does not support comments)
   - Unquoted keys
   - Single quotes instead of double quotes
3. All fields in `pod.json` are optional -- if you do not need configuration, delete the file entirely

## Graceful Shutdown

When cldpd receives SIGINT (Ctrl+C), it calls `Session.Stop`, which sends SIGTERM to the container via `docker stop` with a 10-second timeout. If the container does not exit within the timeout, Docker escalates to SIGKILL.

Possible outcomes:

- Container exits cleanly within the timeout -- `EventContainerExited` is emitted with the exit code
- Container is killed after timeout -- `EventContainerExited` is emitted with exit code 137
- Stop itself fails -- the CLI exits; the container may remain running and must be cleaned up manually

The `--rm` flag ensures containers are removed after exit. If the process is killed before `--rm` can take effect, a stale container may remain (see "Container Name Conflict" above).

## Event Channel Backpressure

If you use the library API and do not consume `session.Events()`, the internal channel buffer (256 entries) will fill under high output volume. Once full, the terminal lifecycle event (`ContainerExited` or `Error`) blocks until space is available. This means `session.Wait()` will also block indefinitely.

**Solution:** Always consume `Events()` via `range`, or use `Stop`/`Wait` only when container output is known to be low-volume.

## Next Steps

- [Testing Guide](1.testing.md) -- How to test code that uses cldpd
- [API Reference](../3.reference/1.api.md) -- Error types and function behaviour
