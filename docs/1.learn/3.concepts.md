---
title: Concepts
description: Core abstractions and mental models for cldpd
author: zoobzio
published: 2026-02-21
updated: 2026-02-22
tags:
  - Concepts
  - Architecture
---

# Concepts

cldpd has six abstractions. Understanding them is sufficient to use the library, extend it, or swap out its internals.

## Pod

A pod is a unit of work. It maps to a directory on disk at `~/.cldpd/pods/<name>/` containing a Dockerfile and optional `pod.json` and `template.md` files.

The pod name is the directory name. cldpd does not generate or interpret Dockerfiles -- what goes inside the container is entirely the user's concern. cldpd discovers the pod, validates that a Dockerfile exists, parses any configuration, and loads any template content. That is the extent of its involvement with pod contents.

A pod with no `pod.json` and no `template.md` is valid. All configuration fields are optional. The zero-value configuration produces sensible defaults: the image is tagged `cldpd-<name>`, no environment variables are injected, no mounts are attached, no working directory is overridden, and no template is prepended to the prompt.

If `template.md` is present, its contents are prepended to the prompt when a session is started. This is where team-specific standing orders go -- git setup, branch workflow, strategy. The template is not used during resume.

See [Pod and PodConfig](../3.reference/2.types.md#pod) in the types reference.

## Runner

The Runner is cldpd's abstraction over container operations. It defines four methods: build an image, run a container, exec into a running container, and stop a container. Nothing in cldpd outside of the Runner implementation knows how containers work.

`DockerRunner` is the standard implementation. It shells out to the Docker CLI via `os/exec`. This is a deliberate choice -- the Docker CLI has been stable for over a decade, and `os/exec` is a single import. The Docker Go SDK would add a substantial dependency tree for structured responses that cldpd does not need.

The Runner interface exists primarily for two reasons:

1. **Testability** -- The Dispatcher can be tested with a mock Runner that never touches Docker. Unit tests cover orchestration logic in isolation.
2. **Substitutability** -- A different container runtime (Podman, containerd) could be supported by implementing the interface. The Dispatcher and CLI would not change.

Runner methods are synchronous and blocking. The async layer lives in Session, not Runner.

See [Runner](../3.reference/2.types.md#runner) in the types reference.

## Session

A Session represents an active pod lifecycle. It is returned by `Dispatcher.Start` and `Dispatcher.Resume`. The caller owns the Session and is responsible for consuming events or calling `Stop`/`Wait`.

Each Session has a unique ID in the format `<podName>-<hex8>`, generated via `crypto/rand`. The container name matches the session ID for Start operations.

A Session manages two internal goroutines:

1. **Container goroutine** -- Calls the Runner's blocking `Run` (or `Exec` for resume), stores the exit code, and closes a pipe.
2. **Event goroutine** -- Reads lines from the pipe, emits `EventOutput` per line, and emits a terminal event (`EventContainerExited` or `EventError`) when the pipe reaches EOF.

The caller interacts with a Session through four methods:

- `ID()` -- Returns the unique session identifier
- `Events()` -- Returns a receive-only channel of typed events
- `Stop(ctx)` -- Graceful shutdown: SIGTERM with 10-second timeout, then blocks until done or ctx expires
- `Wait()` -- Blocks until the container exits and returns the exit code

`Stop` is idempotent. `Events` and `Wait` are independent -- neither requires the other.

See [Session](../3.reference/2.types.md#session) in the types reference.

## Event

Events are the output mechanism. Every lifecycle transition and every line of container output is represented as a typed Event:

| Event Type | Meaning | Data Field | Code Field |
|------------|---------|------------|------------|
| `EventBuildStarted` | Image build begins | Image tag | -- |
| `EventBuildComplete` | Image build succeeds | Image tag | -- |
| `EventContainerStarted` | Container begins running | Container name | -- |
| `EventOutput` | Line of container stdout | Line content | -- |
| `EventContainerExited` | Container exits normally | -- | Exit code |
| `EventError` | Fatal error terminates session | Error message | -- |

Events are delivered over a buffered channel (capacity 256). Lifecycle events (`BuildStarted`, `BuildComplete`, `ContainerStarted`, `ContainerExited`, `Error`) block until delivered -- they are never dropped. Output events use a non-blocking send and are dropped if the channel is full, preventing the event goroutine from stalling.

The channel is closed after the terminal event (`ContainerExited` or `Error`). Callers may `range` over `Events()` to consume the full stream.

See [Event and EventType](../3.reference/2.types.md#event) in the types reference.

## Dispatcher

The Dispatcher is the orchestrator. It connects pod discovery to container operations. Given a pod name and a GitHub issue URL, it discovers the pod, builds the image, and returns a Session wrapping the running container.

The Dispatcher is stateless -- it does not track running sessions. Each returned `*Session` is self-contained. The caller is responsible for the session's lifecycle.

Two operations are exposed:

- **Start** -- Discovers the pod, resolves `inheritEnv` from host environment, builds the image synchronously, composes the prompt (prepending the template if present), then returns a `*Session` with the container running in a background goroutine. If the build fails, Start returns an error and no Session is created.
- **Resume** -- Derives the container name from the pod name (`cldpd-<podName>`), returns a `*Session` wrapping a `docker exec` into the running container.

Resume does not re-discover the pod or rebuild the image. It assumes the container is already running from a prior Start.

See [Dispatcher](../3.reference/1.api.md#dispatcher) in the API reference.

## Container Naming

Container names follow two conventions:

- **Start**: The container name is the session ID (`<podName>-<hex8>`), unique per invocation. This allows concurrent Start calls for different issues against the same pod.
- **Resume**: The container name is deterministic (`cldpd-<podName>`), derived from the pod name. Resume must target an existing container from a prior Start.

Docker itself is the state store. If the container exists and is running, resume works. If not, it fails with `ErrSessionNotFound`.

## Next Steps

- [Architecture](4.architecture.md) -- How the components compose internally
- [API Reference](../3.reference/1.api.md) -- Function signatures and behaviour
