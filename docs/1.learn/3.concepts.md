---
title: Concepts
description: Core abstractions and mental models for cldpd
author: zoobzio
published: 2026-02-21
updated: 2026-02-21
tags:
  - Concepts
  - Architecture
---

# Concepts

cldpd has four abstractions. Understanding them is sufficient to use the library, extend it, or swap out its internals.

## Pod

A pod is a unit of work. It maps to a directory on disk at `~/.cldpd/pods/<name>/` containing a Dockerfile and an optional `pod.json` configuration file.

The pod name is the directory name. cldpd does not generate or interpret Dockerfiles -- what goes inside the container is entirely the user's concern. cldpd discovers the pod, validates that a Dockerfile exists, and parses any configuration. That is the extent of its involvement with pod contents.

A pod with no `pod.json` is valid. All configuration fields are optional. The zero-value configuration produces sensible defaults: the image is tagged `cldpd-<name>`, no environment variables are injected, and no working directory is overridden.

See [Pod and PodConfig](../3.reference/2.types.md#pod) in the types reference.

## Runner

The Runner is cldpd's abstraction over container operations. It defines three methods: build an image, run a container, and exec into a running container. Nothing in cldpd outside of the Runner implementation knows how containers work.

`DockerRunner` is the standard implementation. It shells out to the Docker CLI via `os/exec`. This is a deliberate choice -- the Docker CLI has been stable for over a decade, and `os/exec` is a single import. The Docker Go SDK would add a substantial dependency tree for structured responses that cldpd does not need.

The Runner interface exists primarily for two reasons:

1. **Testability** -- The Dispatcher can be tested with a mock Runner that never touches Docker. Unit tests cover orchestration logic in isolation.
2. **Substitutability** -- A different container runtime (Podman, containerd) could be supported by implementing the interface. The Dispatcher and CLI would not change.

See [Runner](../3.reference/2.types.md#runner) in the types reference.

## Dispatcher

The Dispatcher is the orchestrator. It connects pod discovery to container operations. Given a pod name and a GitHub issue URL, it discovers the pod, builds the image, starts the container with a Claude Code prompt, and streams output back to the caller.

The Dispatcher does not know how pods are discovered (that is `DiscoverPod`'s concern) or how containers are managed (that is the Runner's concern). It coordinates the sequence: discover, build, run, stream.

Two operations are exposed:

- **Start** -- Full lifecycle: discover pod, build image, run container, stream output, return exit code.
- **Resume** -- Partial lifecycle: derive container name from pod name, exec a follow-up command, stream output.

Resume does not re-discover the pod or rebuild the image. It assumes the container is already running from a prior Start. The container name is deterministic (`cldpd-<podname>`), so no session state is stored anywhere.

See [Dispatcher](../3.reference/1.api.md#dispatcher) in the API reference.

## The Direct Line

Container stdout is the direct line. cldpd passes it through without buffering, parsing, or transforming. What the team leader inside the container writes to stdout appears on the caller's terminal.

This is a deliberate non-feature. cldpd does not interpret Claude Code's output. It does not look for progress markers, extract structured data, or filter noise. The team leader narrates; cldpd relays. The caller reads.

Escalation and completed work route through GitHub -- issue comments, pull requests, commits. The direct line is for real-time observation, not control flow.

## Next Steps

- [Architecture](4.architecture.md) -- How the components compose internally
- [API Reference](../3.reference/1.api.md) -- Function signatures and behaviour
