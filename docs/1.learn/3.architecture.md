---
title: Architecture
description: Component design, data flow, and design rationale
author: zoobzio
published: 2026-02-21
updated: 2026-02-21
tags:
  - Architecture
  - Internals
---

# Architecture

For contributors and power users who want to understand how cldpd works internally.

## Component Overview

```
CLI (cmd/cldpd/main.go)
  |
  v
Dispatcher (dispatcher.go)
  |
  +-- Pod Discovery (pod.go)      -- filesystem -> Pod structs
  +-- Docker Runner (docker.go)   -- Pod -> built image -> running container
  |
  v
Container stdout -> caller's io.Writer
```

Five source files, each with a single concern:

| File | Concern |
|------|---------|
| `errors.go` | Semantic error types |
| `pod.go` | Pod discovery and configuration parsing |
| `docker.go` | Runner interface and Docker CLI implementation |
| `dispatcher.go` | Orchestration of the full pod lifecycle |
| `cmd/cldpd/main.go` | CLI entry point and argument parsing |

## Data Flow

### Start

```
cldpd start myrepo --issue <url>
  |
  v
Parse args: podName="myrepo", issueURL="<url>"
  |
  v
DockerRunner.Preflight() -- verify Docker is available
  |
  v
DiscoverPod("~/.cldpd/pods", "myrepo")
  |
  +-- Stat ~/.cldpd/pods/myrepo/
  +-- Stat ~/.cldpd/pods/myrepo/Dockerfile
  +-- Read ~/.cldpd/pods/myrepo/pod.json (optional)
  +-- Return Pod struct
  |
  v
DockerRunner.Build(tag, pod.Dir, buildArgs)
  |
  +-- docker build -t cldpd-myrepo [--build-arg K=V] ~/.cldpd/pods/myrepo/
  |
  v
DockerRunner.Run(opts, os.Stdout)
  |
  +-- docker run --rm --name cldpd-myrepo [-e K=V] [-w workdir] cldpd-myrepo claude -p "..."
  +-- cmd.Stdout = os.Stdout (direct pass-through)
  +-- Blocks until container exits
  |
  v
Exit with container's exit code
```

### Resume

```
cldpd resume myrepo --prompt "guidance"
  |
  v
Parse args: podName="myrepo", prompt="guidance"
  |
  v
Container name: "cldpd-myrepo" (derived from pod name)
  |
  v
DockerRunner.Exec("cldpd-myrepo", ["claude", "--resume", "-p", "guidance"], os.Stdout)
  |
  +-- docker inspect --format '{{.State.Running}}' cldpd-myrepo
  +-- If not running -> ErrSessionNotFound
  +-- docker exec cldpd-myrepo claude --resume -p "guidance"
  +-- cmd.Stdout = os.Stdout
  +-- Blocks until command exits
  |
  v
Exit with command's exit code
```

## The Runner Interface

The `Runner` interface is the central design decision. It abstracts Docker CLI operations behind three methods:

```go
type Runner interface {
    Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
    Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
    Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
}
```

`DockerRunner` implements this interface using `os/exec`. All `exec.Cmd` construction, exit code parsing, and stderr handling are isolated here. Nothing else in the package imports `os/exec`.

This boundary serves two purposes:

1. **Testability** -- The Dispatcher can be tested with a mock Runner that never touches Docker. Unit tests cover orchestration logic; integration tests cover the Docker interaction.

2. **Substitutability** -- The interface could be implemented against a different container runtime without changing the Dispatcher or CLI.

## Container Naming

Container names follow a deterministic convention: `cldpd-<podname>`. This means:

- No session state is stored anywhere. The container name is derived from the pod name.
- Only one instance of a pod can run at a time. Docker rejects duplicate container names.
- Resume finds the container by deriving the name, not by looking up stored state.
- Docker itself is the state store. If the container exists and is running, resume works. If not, it fails.

## Design Q&A

**Why os/exec instead of the Docker API?**

The Docker Go SDK is a substantial dependency tree. `os/exec` wrapping the Docker CLI is a single import, and the CLI has been stable for over a decade. The tradeoff is structured responses vs. exit codes, but since cldpd does not interpret container output, exit codes are sufficient.

**Why --rm on containers?**

Pods are ephemeral. Once the task is complete and the container exits, there is no reason to keep it. `--rm` ensures cleanup. Resume works while the container is running; after exit, the container is gone and resume returns `ErrSessionNotFound`.

**Why no session persistence?**

The deterministic container name (`cldpd-<podname>`) eliminates the need for session tracking. Resume derives the name from the pod name and checks Docker directly. No files, no databases, no in-memory maps.

**Why does Exec preflight with docker inspect?**

`docker exec` against a nonexistent container returns exit code 1, which is ambiguous -- commands also legitimately exit with code 1. `docker inspect --format '{{.State.Running}}'` provides an unambiguous check: the container exists and is running, or it does not. This is version-independent and does not rely on parsing error messages.

## Performance

cldpd adds negligible overhead. The hot path is `io.Copy` from a pipe to stdout, which is bounded by Docker's output rate, not cldpd. Image builds are Docker's domain. The `docker inspect` preflight in resume adds one subprocess invocation (~50ms).

## Next Steps

- [API Reference](../2.reference/1.api.md) -- Function signatures and behaviour
- [Types Reference](../2.reference/2.types.md) -- Type definitions and configuration
