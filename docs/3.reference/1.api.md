---
title: API Reference
description: Complete function documentation for cldpd
author: zoobzio
published: 2026-02-21
updated: 2026-02-22
tags:
  - Reference
  - API
---

# API Reference

## Dispatcher

### NewDispatcher

```go
func NewDispatcher(podsDir string, runner Runner) *Dispatcher
```

Creates a Dispatcher that discovers pods from `podsDir` and executes Docker operations via `runner`.

```go
d := cldpd.NewDispatcher("/home/user/.cldpd/pods", &cldpd.DockerRunner{})
```

### DefaultPodsDir

```go
func DefaultPodsDir() (string, error)
```

Returns the conventional pods directory: `~/.cldpd/pods/`.

Returns an error if the user's home directory cannot be determined.

```go
dir, err := cldpd.DefaultPodsDir()
// dir == "/home/user/.cldpd/pods"
```

### Dispatcher.Start

```go
func (d *Dispatcher) Start(ctx context.Context, podName string, issueURL string) (*Session, error)
```

Discovers the named pod, builds its Docker image synchronously, then returns a `*Session` representing the running container. The image build completes before Start returns -- if the build fails, Start returns an error and no Session is created.

If the pod has a `template.md` file, its contents are prepended to the prompt (separated by a blank line). The template provides standing orders for the team lead agent. Resume sessions do not use the template.

The returned Session emits events in order:

```
BuildStarted -> BuildComplete -> ContainerStarted -> Output* -> ContainerExited
```

On runtime failure: events up to `ContainerStarted`, then `Output*`, then `Error`.

The Dispatcher resolves `inheritEnv` entries via two-tier resolution: names whose values are present on the host (via `os.Getenv`) are eagerly merged into the `Env` map (passed as `-e K=V`). Names not set on the host are deferred to Docker via `InheritEnv` in `RunOptions` (passed as bare `-e NAME`), allowing Docker to inherit them from the host environment at run time.

The caller is responsible for calling `session.Stop` or `session.Wait`.

**Errors:**
- `ErrPodNotFound` -- pod directory does not exist
- `ErrInvalidPod` -- pod directory exists but has no Dockerfile
- `ErrBuildFailed` -- Docker image build failed

```go
session, err := d.Start(ctx, "myrepo", "https://github.com/org/repo/issues/42")
```

### Dispatcher.Resume

```go
func (d *Dispatcher) Resume(ctx context.Context, podName string, prompt string) (*Session, error)
```

Returns a `*Session` wrapping a follow-up exec into an already-running container for the named pod. Resume does not build an image. The container name is derived deterministically from the pod name (`cldpd-<podName>`).

The returned Session emits events in order:

```
ContainerStarted -> Output* -> ContainerExited
```

The caller is responsible for calling `session.Stop` or `session.Wait`.

**Errors:**
- `ErrSessionNotFound` -- no running container named `cldpd-<podName>`

```go
session, err := d.Resume(ctx, "myrepo", "Focus on error handling")
```

## Session

### Session.ID

```go
func (s *Session) ID() string
```

Returns the unique session identifier in the format `<podName>-<hex8>`.

```go
fmt.Println(session.ID()) // "myrepo-a1b2c3d4"
```

### Session.Events

```go
func (s *Session) Events() <-chan Event
```

Returns a receive-only channel of typed events. The channel is closed after the terminal event (`ContainerExited` or `Error`). Callers may `range` over this channel to consume the full event stream.

Consuming `Events()` is optional. `Wait()` returns as soon as the container exits, independent of whether `Events()` is consumed. Under high output volume, output events may be dropped if the buffer (256 entries) fills. The terminal event may also be dropped if the buffer is full when the container exits, but the channel is always closed as the definitive terminal signal.

```go
for event := range session.Events() {
    switch event.Type {
    case cldpd.EventOutput:
        fmt.Println(event.Data)
    case cldpd.EventContainerExited:
        fmt.Printf("exited with code %d\n", event.Code)
    case cldpd.EventError:
        fmt.Fprintf(os.Stderr, "error: %s\n", event.Data)
    }
}
```

### Session.Stop

```go
func (s *Session) Stop(ctx context.Context) error
```

Initiates graceful shutdown of the container. Calls `runner.Stop` with a 10-second SIGTERM timeout, then blocks until the container goroutine exits or `ctx` expires.

Stop is idempotent: calling it on an already-stopped session returns nil immediately.

**Errors:**
- `ErrStopFailed` (wrapped) -- `docker stop` failed for a reason other than "container not found"
- `ctx.Err()` -- context expired before the container exited

```go
if err := session.Stop(ctx); err != nil {
    // handle stop failure
}
```

### Session.Wait

```go
func (s *Session) Wait() (int, error)
```

Blocks until the container exits and returns its exit code and any process-level error. A non-zero exit code does not itself produce an error -- check the returned code.

Wait is independent of Events: it can be called without consuming the event channel.

```go
code, err := session.Wait()
```

## Pod Discovery

### DiscoverPod

```go
func DiscoverPod(podsDir, name string) (Pod, error)
```

Loads a single pod definition by name from the given pods directory. Validates that the Dockerfile exists, parses `pod.json` if present, expands `~` in mount source paths to the user's home directory, and loads `template.md` if present.

**Errors:**
- `ErrPodNotFound` -- directory `<podsDir>/<name>/` does not exist
- `ErrInvalidPod` -- directory exists but contains no Dockerfile
- Parse error -- `pod.json` exists but is malformed JSON
- Read error -- `template.md` exists but cannot be read

```go
pod, err := cldpd.DiscoverPod("/home/user/.cldpd/pods", "myrepo")
```

### DiscoverAll

```go
func DiscoverAll(podsDir string) ([]Pod, error)
```

Loads all valid pods from the given directory. Skips entries that are not directories or lack a Dockerfile. Returns a slice sorted by pod name.

```go
pods, err := cldpd.DiscoverAll("/home/user/.cldpd/pods")
```

## Docker Operations

### DockerRunner.Preflight

```go
func (d *DockerRunner) Preflight(ctx context.Context) error
```

Defined on the `Runner` interface. Checks that the Docker daemon is reachable by running `docker info`.

**Errors:**
- `ErrDockerUnavailable` -- Docker daemon cannot be contacted

```go
runner := &cldpd.DockerRunner{}
if err := runner.Preflight(ctx); err != nil {
    // Docker is not available
}
```

### DockerRunner.Build

```go
func (d *DockerRunner) Build(ctx context.Context, tag string, dir string, buildArgs map[string]string) error
```

Builds a Docker image from the Dockerfile in `dir`, tagged with `tag`. Build arguments are passed as `--build-arg` flags.

**Errors:**
- `ErrBuildFailed` -- build exited with non-zero status

### DockerRunner.Run

```go
func (d *DockerRunner) Run(ctx context.Context, opts RunOptions, stdout io.Writer) (int, error)
```

Starts a container with the given options, streams stdout to the provided writer, and blocks until the container exits. Returns the exit code.

A non-zero exit code is returned as `(code, nil)` -- it is not itself an error. Process-level failures (context cancellation, exec errors) return `(-1, err)`.

### DockerRunner.Exec

```go
func (d *DockerRunner) Exec(ctx context.Context, container string, cmd []string, stdout io.Writer) (int, error)
```

Runs a command in an already-running container. Preflights with `docker inspect` to verify the container exists and is running before attempting the exec.

**Errors:**
- `ErrSessionNotFound` -- container does not exist or is not running

### DockerRunner.Stop

```go
func (d *DockerRunner) Stop(ctx context.Context, container string, timeout time.Duration) error
```

Sends SIGTERM to the named container via `docker stop`, waits up to `timeout`, then SIGKILL if needed. If the container is not found (already removed), Stop returns nil.

**Errors:**
- `ErrStopFailed` -- `docker stop` exited with non-zero status for a reason other than "No such container"
